import prisma from "../../../lib/prisma";
// import type { NextApiRequest, NextApiResponse } from "next"; ts todo
import { getSession } from "next-auth/client";
import { fetchProducts } from "../fetch";

async function sanitize(product) {
  console.log("product:", product);

  // id: 4843341349001,
  // title: 'Sunshine in a Jar Cream',
  // handle: 'sunshine-in-a-jar-cream',
  // body_html: '',
  // published_at: '2021-09-06T12:48:00-06:00',
  // created_at: '2020-04-09T17:36:15-06:00',
  // updated_at: '2021-09-14T12:35:15-06:00',
  // vendor: 'Healing Hollow Essential Oil Co.',
  // product_type: 'Body Care',
  // tags: [],
  // variants: [],
  // images: [],
  // options: []

  const {
    id,
    title,
    handle,
    body_html,
    published_at,
    created_at,
    updated_at,
    vendor,
    product_type,
    tags,
    variants,
    images,
    options,
  } = product;

  const data = {
    id,
    title,
    handle,
    body_html,
    vendor,
    product_type,
    publishedAt: published_at,
    updatedAt: updated_at,
    tags,
    // variants,
    // images,
    // options,
  };

  return data;
}

// POST /api/hydrate
export default async (req, res) => {
  const session = await getSession({ req });

  if (!session) {
    return res.status(401).json({ reason: "Unauthorized" });
  }

  if (req.method === "POST") {
    try {
      const { body } = req;
      let json = [];

      if (body) {
        json = await fetchProducts();
      }

      let productArray = await json.products.map((product) => {
        const {
          id,
          title,
          handle,
          body_html,
          published_at,
          created_at,
          updated_at,
          vendor,
          product_type,
          tags,
          variants,
          images,
          options,
        } = product;

        const data = {
          id,
          title,
          handle,
          body_html,
          vendor,
          product_type,
          publishedAt: published_at,
          updatedAt: updated_at,
          tags,
          // todo
          // variants,
          // images,
          // options,
        };

        return data;
      });
      console.log('productArray:', productArray[0], productArray.length)

      // const result = await prisma.product.createMany({
      //   data: productArray,
      //   // skipDuplicates: true, // todo
      // });

      const result = await prisma.product.create({
        data: {
          id: productArray[0].id,
          title: productArray[0].title,
          handle: productArray[0].handle,
          body_html: productArray[0].body_html,
          vendor: productArray[0].vendor,
          product_type: productArray[0].product_type,
          publishedAt: productArray[0].publishedAt,
          updatedAt: productArray[0].updatedAt,
          tags: productArray[0].tags
        }
      })

      console.log("result:", result);
      // let result = productArray[0];

      return res.status(200).json(result);
    } catch (error) {
      return res.status(422).json(error);
    }
  }

  res.end();
};


// model Product {
//   id           Int      @id @default(autoincrement())
//   title        String
//   handle       String?
//   body_html    String?
//   vendor       String?
//   product_type String?
//   publishedAt  DateTime @default(now()) @map(name: "published_at")
//   updatedAt    DateTime @updatedAt @map(name: "updated_at")
//   author       User?    @relation(fields: [authorId], references: [id])
//   authorId     Int?
//   tags         String[]
//   variants     Variant? @relation(fields: [variantId], references: [id])
//   variantId    Int
//   images       Image?   @relation(fields: [imageId], references: [id])
//   imageId      Int
//   options      Option?  @relation(fields: [optionId], references: [id])
//   optionId     Int

//   @@map(name: "products")
// }
